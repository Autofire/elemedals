# Pivot
# Main player.
# TODO:
# Give Pivot a turn animation (Will not interfere with other actions)
# Fix flinch-during-jump
# Fix damage hitboxes while running
# Fix second sword swing animation

{
on_enter_hurt_anim: "debug(['HP: ',hitpoints - 1])",

id: "pivot_playable",
prototype: [
	"player_controlled_platformer_character",
	"pivot_anim_general",
	"pivot_anim_sword",
],

editor_info: { category: "player" },
solid_dimensions: ["player","common","boss"],
collide_dimensions: ["common","enemy","boss","hazard"],
vehicle: false,
hitpoints: 30,
mass: 5,
is_human: true,
friction: 2200,
traction_in_air: 100,
traction_in_water: 1000,
feet_width: 5,
zorder: "@include data/zorder.cfg:player",

properties: {
	///////////////
	// VARIABLES //
	///////////////
	airSpeed:   { type: "int", default: 30 },

	jumpTicks: { type: "int", init: 0 },
	jumpPower: { type: "int", init: 1800 },
	 
	cycleOfLastUp: 	{ type: "int", default: 0 },	
	cycleOfLastSwordInput: { type: "int", default: 0 },

	// Equipment -- These will change often throughout the game
	sword: { type: "string", default: 'calibur' },

	///////////////
	// CONSTANTS //
	///////////////
	cTEAM: "'player'",
	cLEFT: -1,
	cRIGHT: 1,
	
	cBASE_RUN_SPEED: "int :: 190",
	
	cFLINCH_THRESHOLD: 0,
	cHURT_VELOCITY_Y: "-1100",
	cHURT_VELOCITY_X: "250",
	
	cATTACK_DAMAGE: "5",
	cDAMAGE_COOLDOWN: "-1",
	
	cSOONEST_SWORD_REQUEST: "10",	// The earliest the player can be when
									  // attempting to swing their sword. This
									  // will probably vary based on sword.
	/***************************************************************************
	 * ANIMATIONS CONSTANTS
	 *  Pivot uses an animation numbering/suffixing system to make it easier to
	 * expand upon his animation set.
	 *
	 * We are assuming that animations are formatted as <group>#S where S is a
	 * letter representing the animation type, and # is a number for the
	 * animation. There can be no type if there is no number for the animation
	 *
	 * Check cANIM_SUFFIXES for a full listing of suffixes. If you use one
	 * that doesn't exist, YOU COULD BREAK THE SYSTEM.
	 ***************************************************************************/
	cANIM_SUFFIXES: "{string -> string} ::
	   {'E': 'End',
		'S': 'Start'
	   }",
	   
	// If the animation has a number, we want to read the two characters before it
	cCURRENT_ANIM_SUFFIX: "string <- animation[size(animation) - 1]",
	
	cANIM_TYPE: "string ::
		if(cCURRENT_ANIM_SUFFIX in keys(cANIM_SUFFIXES),
		   cANIM_SUFFIXES[cCURRENT_ANIM_SUFFIX],
		   'none')",
	
	cANIM_NUM:   "int ::
		CharToInt(string <- animation[size(animation) - number_offset])
			where number_offset = if(cANIM_TYPE = 'none', 1, 2)
		",
			
	cANIM_GROUP: "string :: animation[ : _anim_name_size]
		where _anim_name_size =
			if(cANIM_NUM  = null and cANIM_TYPE  = 'none',
			   size(animation),	 // Return the full name if no suffixes
			   cANIM_NUM != null and cANIM_TYPE != 'none',
			   size(animation) - 2, // Trim both letter and number suffix
			   size(animation) - 1  // Trim either letter or number suffix
			)
	",
	
	// Overloaded from hittable.cfg
	cMINOR_ATTACK_NUM: "if(cANIM_NUM = null, 1, cANIM_NUM)",

	/*******************
	 * ANIMATION BOOLS *
	 *******************/
	cIN_GROUNDED_ANIM: "bool :: bool(
		self.animation in ['stand', 'run']
	 or cIN_END_ANIM
	)",
	
	cIN_END_ANIM: "bool :: cANIM_TYPE = 'End'",
		
	cIN_CONTROLLABLE_ANIM: "bool :: bool(
		self.animation in ['stand', 'run', 'jump', 'beginFall', 'fall']
		//or cIN_END_ANIM
	)",
	 
	cCAN_TURN: "bool :: bool(cANIM_GROUP != sword)",
	
	cIN_LAST_SWORD_ATTACK: "(
		sword + (cANIM_NUM + 1) not in available_animations
	)",
			
	vREQUEST_SWORD_ATTACK: "
		if(cANIM_GROUP = sword and cIN_END_ANIM and not cIN_LAST_SWORD_ATTACK,
			set(animation, NextAnimationInChain(sword, cANIM_NUM)),
		   cIN_CONTROLLABLE_ANIM,
			[set(animation, NextAnimationInChain(sword, 0)),
			 add(major_attack_num, 1)
			]
		)
	",
	
	/******************
	 * VOID CONSTANTS *
	 ******************/
	
	/*************
	 * FUNCTIONS *
	 *************/
	// TODO: Move the gui stuff to its own file
	guiHeartDisplay: {
		type: "obj heart_display",
		init: "object('heart_display', 27+0, 27+0, 1)",
		persistent: false,
	},
	SetUpGui: "def() -> commands 
		map(components,
			'gui_element', [
				remove_object(gui_element),
				add_object(gui_element),
			]
		) where components = [guiHeartDisplay]
	",


	/******************************************************
	 * CharToInt
	 *  This function accepts a single character, and then
	 * converts it to an integer. If it isn't a valid
	 * number, it returns 0.
	 ******************************************************/
	CharToInt: "def(string inStr) -> int
		if(inStr in numbers, int(inStr), 0)
			where numbers = ['1','2','3','4','5','6','7','8','9','0']
	",
	
	/******************************************************
	 * FilterNull
	 *  This function accepts an integer or a null. If
	 * given a null, it returns an empty string. Otherwise,
	 * it returns the integer.
	 ******************************************************/
	FilterNull: "def(int|null num) -> int|string
		if(num = null, '', num)
	",
	
	/******************************************************
	 * TryTurn
	 *  Given a direction, this function will attempt to
	 * set the facing to the new one, based on cCAN_TURN.
	 ******************************************************/
	TryTurn: "def(int newdir) -> commands
		if(cCAN_TURN, set(facing, newdir))",
	
	// Overloading (from hittable) because we want to flinch in air
	HandleFlinch: "def(obj hittable collide_with) -> commands
		execute(me,
			if(final_damage_amount(collide_with,
								   collide_with.cATTACK_DAMAGE) >= cFLINCH_THRESHOLD,
				cause_flinch(collide_with))
	)",
	
	/******************************************************
	 * NextAnimationInChain
	 *  Given the base name of an animation and the current
	 * animation number, this function will check if there
	 * is there is another animation in a chain, where the
	 * animations are formatted as <name><num><type>. If
	 * There is one that ends in 'S', this function will
	 * return that one. Otherwise, it will try without the
	 * 'S'. If all else fails, it will return fallbackAnim.
	 ******************************************************/
	NextAnimationInChain: "def(string animName,	// Name of the animation
							   int    animNum,	 // CURRENT anim number
							   string fallbackAnim = 'stand') -> string
	
		if(animName + (animNum + 1) + 'S' in available_animations,
			animName + (animNum + 1) + 'S',  // Return
		   animName + (animNum + 1) in available_animations,
			animName + (animNum + 1),		// Return
			fallbackAnim					 // Return
		)
	",
},

#ANIMATION HANDLES#
on_create: "[animation('stand'), SetUpGui(), set(jumpTicks, 0) ]",
on_collide_feet: "if(animation not in ['calibur1','hurt'], animation('stand'))",

# -- stuff that is related to the player's input follows
on_process: "[fire_event('bookkeep'),
	if((ctrl_left or ctrl_right) and (animation = 'stand'),
		set(animation, 'run')
	),
		
	if(ctrl_left  and cIN_CONTROLLABLE_ANIM, [
		TryTurn(cLEFT),
		if(is_standing, add(velocity_x, -cRUN_SPEED), add(velocity_x, -airSpeed))]),
					
	if(ctrl_right and cIN_CONTROLLABLE_ANIM, [
		TryTurn(cRIGHT),
		if(is_standing, add(velocity_x, cRUN_SPEED), add(velocity_x, airSpeed))]),
	
//	debug(time_in_animation),
#		if(cIN_GROUNDED_ANIM and (not is_standing), animation('beginFall')),#
]",

on_process_stand: "if(
	not is_standing,
		animation('beginFall')
)",			
on_process_run: "if(
	not (ctrl_left or ctrl_right),
		animation('stand'),
	not is_standing,
		animation('beginFall')
)",
on_end_stand_anim: "animation('stand')",
on_end_run_anim:   "animation('run')",
on_end_hurt_anim:  "animation('beginFall')",

# -- Jumping and falling -- #
on_ctrl_jump: "if(is_standing and cIN_GROUNDED_ANIM,
				[animation('jump'), add(velocity_y, -jumpPower)]
				)",
				
on_process_jump: "if(not ctrl_jump, [
				if(velocity_y < 0, set(velocity_y, -200)),
				animation('beginFall')],
				
				velocity_y >= 0, animation('beginFall'),
				
				add(velocity_y, -20)
				)",
				
on_end_beginFall_anim: "[animation('fall')]",

on_end_anim: "[
	if(cANIM_GROUP = sword, fire_event('end_sword_anim')),
]",

/*******************
 * ATTACK HANDLING *
 *******************/

// Swords //
on_ctrl_tongue: "fire_event('ctrl_sword')",

on_ctrl_sword: "[
	set(cycleOfLastSwordInput, cycle),
	vREQUEST_SWORD_ATTACK
]",

on_end_sword_anim: "[
	// If the player has given a recent enough attack input, continue the
	// chain. The idea is that button mashing WILL let you slash slightly
	// faster by skipping the first end animation frame.
if( not cIN_LAST_SWORD_ATTACK and tRECENT_SWORD_REQUEST,
		set(animation, NextAnimationInChain(sword, cANIM_NUM)),
	
	// Attempt to transition into an end animation.
	animation + 'E' in available_animations,
		animation(animation + 'E'),
		
	// If we're in a start animation, attempt to switch into the slash that
	// comes right afterward.
	cANIM_TYPE = 'Start' and
	 (cANIM_GROUP + FilterNull(cANIM_NUM)) in available_animations,
		animation(cANIM_GROUP + FilterNull(cANIM_NUM)),
	
	// If the player is done attacking, start standing.
	animation('stand')
	
	) where tRECENT_SWORD_REQUEST =
				me.cycle - cycleOfLastSwordInput < cSOONEST_SWORD_REQUEST,
]",

// Bombs //
on_ctrl_attack: "spawn('bomb_blast', 30, 0, facing)",

#ANIMATIONS#
//animation: "@include data/objects/pivot/pivot_anim_general.json",

on_ctrl_up: "if(cycleOfLastUp + 20 < cycle,
			set(cycleOfLastUp, cycle),
			speech_dialog(level.player,
		[~Thanks for downloading this demo!
		  There are a few things that need to be said.~],
		[~First off, this game is inspired by Spiral Knights,
		  and it will always be completely free.~],
		[~This tileset came from Frogatto. The Frogatto
		  cTEAM gave permission to use it for now.~],
		[~Lastly, this is a very early version.
		  Things will change radically in the future!~],
		))",
}
