# Pivot
# Main player.
# TODO:
# Give Pivot a turn animation (Will not interfere with other actions)
# Fix flinch-during-jump (fixed?)
# Fix damage hitboxes while running
# Fix second sword swing animation

{
on_enter_hurt_anim: "debug(['HP: ',hitpoints - 1])",

id: "pivot_playable",
prototype: ["player_controlled_platformer_character"],
editor_info: { category: "player" },
solid_dimensions: ["player","common","boss"],
collide_dimensions: ["common","enemy","boss","hazard"],
vehicle: false,
hitpoints: 30,
mass: 5,
is_human: true,
friction: 2200,
traction_in_air: 100,
traction_in_water: 1000,
feet_width: 5,
zorder: "@include data/zorder.cfg:player",

properties: {
	flinch_threshold: 0,
	hurt_velocity_y: "-1100",
	hurt_velocity_x: "250",
	team: "'player'",
	left: -1,
	right: 1,
	
	base_runspeed: "int :: 190",
	jumpticks:  { type: "int", default: 0 },
	airspeed:   { type: "int", default: 30 },
	jump_power: { type: "int", default: -1800 },
	cycle_of_last_up: 	{ type: "int", default: 0 },	
	cycle_of_last_attack: { type: "int", default: 0 },
	
	attack_damage: "5",
	damage_cooldown: "-1",
	
	// Equipment -- These will change often throughout the game
	sword: { type: "string", default: 'calibur' },
	
	
	# ANIMATIONS CONSTANTS #
	// Pivot uses an animation numbering/suffixing system to make it easier to
	// expand upon his animation set.
	//
	// We are assuming that animations are formatted as xxxxx#S where S is a
	// letter representing the animation type, and # is a number for the
	// animation. There can be no type if there is no number for the animation
	//
	// Check cANIM_SUFFIXES for a full listing of suffixes. If you use one
	// that doesn't exist, YOU COULD BREAK THE SYSTEM.

	cANIM_SUFFIXES: "{string -> string} ::
	   {'E': 'End',
		'S': 'Start'
	   }",
	   
	// If the animation has a number, we want to read the two characters before it
	cCURRENT_ANIM_SUFFIX: "string <- animation[size(animation) - 1]",
	
	cANIM_TYPE: "string ::
		if(cCURRENT_ANIM_SUFFIX in keys(cANIM_SUFFIXES),
		   cANIM_SUFFIXES[cCURRENT_ANIM_SUFFIX],
		   'none')",
	
	cANIM_NUMBER:   "int|null ::
		CharToInt(string <- animation[size(animation) - number_offset])
			where number_offset = if(cANIM_TYPE = 'none', 1, 2)
		",
			
	cANIM_NAME: "string :: animation[ : _anim_name_size]
		where _anim_name_size =
			if(cANIM_NUMBER  = null and cANIM_TYPE  = 'none',
			   size(animation),	 // Return the full name if no suffixes
			   cANIM_NUMBER != null and cANIM_TYPE != 'none',
			   size(animation) - 2, // Trim both letter and number suffix
			   size(animation) - 1  // Trim either letter or number suffix
			)
	",
	
	// Overloaded from hittable.cfg
	cMINOR_ATTACK_NUM: "if(cANIM_NUMBER = null, 1, cANIM_NUMBER)",
	
	# -- gui -- #
	gui_heart_display: {
		type: "obj heart_display",
		init: "object('heart_display', 27+0, 27+0, {})",
		persistent: false,
	},
	
	set_up_gui: "def() -> commands [
		map(components,
			'gui_element', [
				remove_object(gui_element),
				add_object(gui_element),
			]
		) where components = [gui_heart_display]
	]",


	# -- functions -- #
	/******************************************************
	 * CharToInt
	 *  This function accepts a single character, and then
	 * converts it to an integer. If it isn't a valid
	 * number, it returns null.
	 ******************************************************/
	CharToInt: "def(string inStr) -> int|null
		if(inStr in numbers, int(inStr), null)
			where numbers = ['1','2','3','4','5','6','7','8','9','0']
	",
	
	/******************************************************
	 * FilterNull
	 *  This function accepts an integer or a null. If
	 * given a null, it returns an empty string. Otherwise,
	 * it returns the integer.
	 ******************************************************/
	FilterNull: "def(int|null num) -> int|string
		if(num = null, '', num)
	",
	
	grounded_anim: "bool :: bool(
		self.animation in ['stand', 'run']
	 or in_end_anim
	)",
	
	// Make a list of our sword animations based upon our
	// equipped sword
	sword_anim: "bool :: bool(self.animation in
		map(['1','2','3'], sword+value)
	)",
	
	in_end_anim: "bool :: cANIM_TYPE = 'End'",
		
	controllable_anim: "bool :: bool(
		self.animation in ['stand', 'run', 'jump', 'beginFall', 'fall']
		or in_end_anim
	)",
	 
	can_turn: "bool :: bool(not sword_anim)",
	
	turn: "def(int newdir) -> commands
		if(newdir != facing and can_turn, set(facing, newdir))",
	
	// Overloading (from hittable) because we want to flinch in air
	handle_flinch: "def(obj hittable collide_with) -> commands
		execute(me,
			if(final_damage_amount(collide_with, collide_with.attack_damage) >= flinch_threshold,
				cause_flinch(collide_with))
	)",
},

#ANIMATION HANDLES#
on_create: "[animation('stand'), set_up_gui()]",
on_collide_feet: "if(animation not in ['calibur1','hurt'], animation('stand'))",

# -- stuff that is related to the player's input follows
on_process: "[fire_event('bookkeep'),
	if(     (ctrl_left or ctrl_right)
		and (animation = 'stand' or in_end_anim),
			set(animation, 'run')),
		
	if(ctrl_left  and not sword_anim, [
		if(can_turn, turn(left)),
		if(is_standing, add(velocity_x, -runspeed), add(velocity_x, -airspeed))]),
					
	if(ctrl_right and not sword_anim, [
		if(can_turn, turn(right)),
		if(is_standing, add(velocity_x, runspeed), add(velocity_x, airspeed))]),
	
//	debug(time_in_animation),
#		if(grounded_anim and (not is_standing), animation('beginFall')),#
			]",

on_process_stand: "if(
	not is_standing,
		animation('beginFall')
)",			
on_process_run: "if(
	not (ctrl_left or ctrl_right),
		animation('stand'),
	not is_standing,
		animation('beginFall')
)",
on_end_stand_anim: "animation('stand')",
on_end_run_anim:   "animation('run')",
on_end_hurt_anim:  "animation('beginFall')",

# -- Jumping and falling -- #
on_ctrl_jump: "if(is_standing and grounded_anim,
				[animation('jump'), add(velocity_y, jump_power)]
				)",
				
on_process_jump: "if(not ctrl_jump, [
				if(velocity_y < 0, set(velocity_y, -200)),
				animation('beginFall')],
				
				velocity_y >= 0, animation('beginFall'),
				
				add(velocity_y, -20)
				)",
				
on_end_beginFall_anim: "[animation('fall')]",

# -- General attacks -- #
on_ctrl_tongue: "[set(cycle_of_last_attack, cycle),
	if(controllable_anim, [
		if(  in_end_anim
		 and cANIM_NUMBER != null
		 and sword + (cANIM_NUMBER + 1) in available_animations,
		 	
		 	// This runs if we are continuing a sword combo.
		 	// This if statement checks if there is a start anim available.
		 	// If there isn't, just run the normal one.
		 	if(sword + (cANIM_NUMBER + 1) + 'S' in available_animations,
		 		animation(sword + (cANIM_NUMBER + 1) + 'S'),
		 		animation(sword + (cANIM_NUMBER + 1))
		 	),
		 	
		 	[animation(sword + '1'),
		 	 add(major_attack_num, 1)]
		 	 
		) // end-if (in_end_anim...
	])
]",

on_ctrl_attack: "spawn('bomb_blast', 30, 0, facing)",

on_end_anim: "[
	if( animation + 'E' in available_animations,
			animation(animation + 'E'),
		in_end_anim,
			animation('stand')
	),
	
	if(  cANIM_TYPE = 'Start'
	 and (cANIM_NAME + FilterNull(cANIM_NUMBER)) in available_animations,
		animation(cANIM_NAME + FilterNull(cANIM_NUMBER))
	)
]",

on_ctrl_up: "if(cycle_of_last_up + 20 < cycle,
			set(cycle_of_last_up, cycle),
			speech_dialog(level.player,
		[~Thanks for downloading this demo!
		  There are a few things that need to be said.~],
		[~First off, this game is inspired by Spiral Knights,
		  and it will always be completely free.~],
		[~This tileset came from Frogatto. The Frogatto
		  team gave permission to use it for now.~],
		[~Lastly, this is a very early version.
		  Things will change radically in the future!~],
		))",

#ANIMATIONS#
animation: "@include data/objects/pivot/pivot_anim_general.cfg",
}
